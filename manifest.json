{
  "id": "rivestream-tmdb",
  "name": "Rivestream (TMDB)",
  "version": "1.1.0",
  "manifestURI": "https://raw.githubusercontent.com/Farqiplier/MyTestExtension/refs/heads/main/manifest.json",
  "language": "javascript",
  "type": "onlinestream-provider",
  "description": "Streaming provider using TMDB metadata and Rivestream embeds. Supports Movies and TV Shows.",
  "author": "Senior Software Engineer",
  "lang": "en",
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n\nclass Provider {\n  constructor() {\n    this.apiKey = \"963152cd5dd145cfa7496a5e975139e9\";\n    this.apiUrl = \"https://api.themoviedb.org/3\";\n  }\n\n  getSettings() {\n    return {\n      episodeServers: [\"Rivestream\"],\n      supportsDub: false,\n    };\n  }\n\n  /**\n   * Helper to handle different types of mediaId inputs (Playground vs Library)\n   */\n  async resolveMedia(mediaId) {\n    let id = \"\";\n    let type = \"tv\";\n\n    if (typeof mediaId === \"object\" && mediaId !== null) {\n      // Production: SeAnime passes a Media object\n      id = String(mediaId.tmdbId || mediaId.id);\n      type = (mediaId.type || \"tv\").toLowerCase();\n    } else if (typeof mediaId === \"string\" && mediaId.includes(\"/\")) {\n      // Internal: format used by search() -> findEpisodes()\n      const parts = mediaId.split(\"/\");\n      id = parts[0];\n      type = parts[1];\n    } else {\n      // Playground: User enters a raw TMDB ID\n      id = String(mediaId);\n      try {\n        const check = await fetch(`${this.apiUrl}/movie/${id}?api_key=${this.apiKey}`).then(res => res.json());\n        type = (check && check.id) ? \"movie\" : \"tv\";\n      } catch (e) {\n        type = \"tv\";\n      }\n    }\n    return { id, type };\n  }\n\n  async search(query) {\n    const url = `${this.apiUrl}/search/multi?api_key=${this.apiKey}&query=${encodeURIComponent(query.query)}`;\n    const res = await fetch(url).then(res => res.json());\n    \n    return (res.results || [])\n      .filter(m => m.media_type === \"movie\" || m.media_type === \"tv\")\n      .map(m => ({\n        id: `${m.id}/${m.media_type}`,\n        title: m.title || m.name,\n        url: `https://www.themoviedb.org/${m.media_type}/${m.id}`,\n      }));\n  }\n\n  async findEpisodes(mediaId) {\n    const { id, type } = await this.resolveMedia(mediaId);\n    const episodes = [];\n\n    if (type === \"movie\") {\n      episodes.push({\n        id: `${id}/movie`,\n        number: 1,\n        title: \"Full Movie\",\n        url: \"\",\n      });\n    } else {\n      const tvRes = await fetch(`${this.apiUrl}/tv/${id}?api_key=${this.apiKey}`).then(res => res.json());\n      if (!tvRes || !tvRes.seasons) return [];\n\n      for (const season of tvRes.seasons) {\n        if (season.season_number === 0) continue;\n        const sRes = await fetch(`${this.apiUrl}/tv/${id}/season/${season.season_number}?api_key=${this.apiKey}`).then(res => res.json());\n        \n        if (sRes && sRes.episodes) {\n          for (const ep of sRes.episodes) {\n            episodes.push({\n              id: `${id}/tv/${ep.season_number}/${ep.episode_number}`,\n              number: episodes.length + 1,\n              title: `S${ep.season_number}E${ep.episode_number} - ${ep.name}`,\n              url: \"\",\n            });\n          }\n        }\n      }\n    }\n    return episodes;\n  }\n\n  async findEpisodeServer(episode, _server) {\n    const parts = episode.id.split(\"/\");\n    const tmdbId = parts[0];\n    const type = parts[1];\n\n    let embedUrl = \"\";\n    if (type === \"movie\") {\n      embedUrl = `https://rivestream.org/embed?id=${tmdbId}&type=movie`;\n    } else {\n      const s = parts[2];\n      const e = parts[3];\n      embedUrl = `https://rivestream.org/embed?id=${tmdbId}&type=tv&season=${s}&episode=${e}`;\n    }\n\n    return {\n      server: \"Rivestream\",\n      videoSources: [\n        {\n          url: embedUrl,\n          quality: \"auto\",\n          type: \"iframe\",\n        },\n      ],\n    };\n  }\n}\n\nnew Provider();\n"
}
