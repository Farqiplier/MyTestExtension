{
  "id": "extractor-provider",
  "name": "Stream Extractor (HLS)",
  "version": "1.0.0",
  "manifestURI": "https://raw.githubusercontent.com/Farqiplier/MyTestExtension/refs/heads/main/manifest.json",
  "language": "javascript",
  "type": "onlinestream-provider",
  "description": "Provider using stream extraction APIs for real HLS streams",
  "author": "Farqiplier",
  "lang": "en",
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n\nclass Provider {\n  constructor() {\n    this.tmdbApiKey = \"963152cd5dd145cfa7496a5e975139e9\";\n    // Alternative Consumet instances\n    this.consumetUrls = [\n      \"https://api.consumet.org\",\n      \"https://consumet-api.vercel.app\",\n      \"https://consumet-jade.vercel.app\"\n    ];\n  }\n\n  getSettings() {\n    return {\n      episodeServers: [\"FlixHQ-Auto\"],\n      supportsDub: false,\n    };\n  }\n\n  async search(query) {\n    try {\n      console.log(\"[Extractor] Search called\");\n      \n      const title = query.media?.title?.english || query.media?.title?.romaji || query.query;\n      const year = query.media?.seasonYear;\n      const isMovie = query.media?.format === \"MOVIE\";\n      const mediaType = isMovie ? \"movie\" : \"tv\";\n      \n      console.log(`[Extractor] Searching: \"${title}\" (${year}), type: ${mediaType}`);\n      \n      let tmdbId = query.media?.idMal;\n      \n      if (!tmdbId || tmdbId === 0) {\n        const searchUrl = `https://api.themoviedb.org/3/search/${mediaType}?api_key=${this.tmdbApiKey}&query=${encodeURIComponent(title)}&year=${year || \"\"}`;\n        const response = await fetch(searchUrl);\n        const data = await response.json();\n        \n        if (!data.results || data.results.length === 0) {\n          console.log(\"[Extractor] No TMDB results\");\n          return [];\n        }\n        \n        return data.results.slice(0, 5).map(item => {\n          const itemYear = item.release_date ? new Date(item.release_date).getFullYear() : \n                          (item.first_air_date ? new Date(item.first_air_date).getFullYear() : null);\n          const itemTitle = item.title || item.name;\n          \n          return {\n            id: `${item.id}/${mediaType}`,\n            title: `${itemTitle}${itemYear ? ` (${itemYear})` : \"\"}`,\n            url: `https://www.themoviedb.org/${mediaType}/${item.id}`,\n            subOrDub: \"sub\",\n          };\n        });\n      }\n      \n      console.log(`[Extractor] Using TMDB ID: ${tmdbId}`);\n      return [{\n        id: `${tmdbId}/${mediaType}`,\n        title: title,\n        url: `https://www.themoviedb.org/${mediaType}/${tmdbId}`,\n        subOrDub: \"sub\",\n      }];\n    } catch (err) {\n      console.error(\"[Extractor] Search error:\", err);\n      return [];\n    }\n  }\n\n  async findEpisodes(Id) {\n    try {\n      console.log(`[Extractor] findEpisodes: ${Id}`);\n      \n      const [tmdbId, mediaType] = Id.split(\"/\");\n      \n      if (mediaType === \"movie\") {\n        return [{ id: Id, number: 1, title: \"Movie\", url: \"\" }];\n      }\n      \n      // Try Consumet FlixHQ for episode list\n      for (const baseUrl of this.consumetUrls) {\n        try {\n          console.log(`[Extractor] Trying to search FlixHQ via ${baseUrl}...`);\n          \n          // Get TV show details from TMDB first\n          const tvUrl = `https://api.themoviedb.org/3/tv/${tmdbId}?api_key=${this.tmdbApiKey}`;\n          const tvResponse = await fetch(tvUrl);\n          const tvData = await tvResponse.json();\n          \n          if (!tvData || !tvData.name) {\n            console.log(`[Extractor] No TV data from TMDB`);\n            continue;\n          }\n          \n          console.log(`[Extractor] TV Show: ${tvData.name}`);\n          \n          // Search FlixHQ\n          const searchUrl = `${baseUrl}/movies/flixhq/${encodeURIComponent(tvData.name)}`;\n          console.log(`[Extractor] FlixHQ search: ${searchUrl}`);\n          \n          const searchResponse = await fetch(searchUrl);\n          if (!searchResponse.ok) {\n            console.log(`[Extractor] ${baseUrl} returned ${searchResponse.status}`);\n            continue;\n          }\n          \n          const searchData = await searchResponse.json();\n          console.log(`[Extractor] FlixHQ search results:`, searchData);\n          \n          if (!searchData.results || searchData.results.length === 0) {\n            console.log(`[Extractor] No FlixHQ results`);\n            continue;\n          }\n          \n          // Find matching show (preferably by type=TV)\n          const match = searchData.results.find(r => r.type === \"TV Show\") || searchData.results[0];\n          console.log(`[Extractor] Using FlixHQ result: ${match.title}, id: ${match.id}`);\n          \n          // Get episode info\n          const infoUrl = `${baseUrl}/movies/flixhq/info?id=${match.id}`;\n          console.log(`[Extractor] FlixHQ info: ${infoUrl}`);\n          \n          const infoResponse = await fetch(infoUrl);\n          const infoData = await infoResponse.json();\n          \n          if (!infoData.episodes || infoData.episodes.length === 0) {\n            console.log(`[Extractor] No episodes from FlixHQ`);\n            continue;\n          }\n          \n          console.log(`[Extractor] Found ${infoData.episodes.length} episodes from FlixHQ`);\n          \n          return infoData.episodes.map((ep, index) => ({\n            id: `${Id}/${match.id}/${ep.id}`,\n            number: ep.number || index + 1,\n            title: ep.title || `Episode ${ep.number || index + 1}`,\n            url: \"\",\n          }));\n        } catch (err) {\n          console.error(`[Extractor] Error with ${baseUrl}:`, err);\n          continue;\n        }\n      }\n      \n      // Fallback: Use TMDB episode list\n      console.log(`[Extractor] FlixHQ failed, using TMDB episodes`);\n      const episodes = [];\n      let absoluteEpisodeNumber = 1;\n      \n      const tvUrl = `https://api.themoviedb.org/3/tv/${tmdbId}?api_key=${this.tmdbApiKey}`;\n      const tvResponse = await fetch(tvUrl);\n      const tvData = await tvResponse.json();\n      \n      if (!tvData || !tvData.number_of_seasons) {\n        return [];\n      }\n      \n      for (let season = 1; season <= Math.min(tvData.number_of_seasons, 5); season++) {\n        const seasonUrl = `https://api.themoviedb.org/3/tv/${tmdbId}/season/${season}?api_key=${this.tmdbApiKey}`;\n        const seasonResponse = await fetch(seasonUrl);\n        const seasonData = await seasonResponse.json();\n        \n        if (!seasonData || !seasonData.episodes) continue;\n        \n        for (const ep of seasonData.episodes) {\n          episodes.push({\n            id: `${Id}/tmdb/${season}/${ep.episode_number}`,\n            number: absoluteEpisodeNumber,\n            title: ep.name || `Episode ${absoluteEpisodeNumber}`,\n            url: \"\",\n          });\n          absoluteEpisodeNumber++;\n        }\n      }\n      \n      return episodes;\n    } catch (err) {\n      console.error(\"[Extractor] findEpisodes error:\", err);\n      return [];\n    }\n  }\n\n  async findEpisodeServer(episode, server) {\n    try {\n      console.log(`[Extractor] findEpisodeServer: ${episode.id}`);\n      \n      const parts = episode.id.split(\"/\");\n      const tmdbId = parts[0];\n      const mediaType = parts[1];\n      \n      // Check if we have FlixHQ ID or TMDB fallback\n      if (parts[2] === \"tmdb\") {\n        console.error(`[Extractor] TMDB fallback episodes don't have streams yet`);\n        throw new Error(\"Stream not available - FlixHQ lookup failed\");\n      }\n      \n      const flixhqId = parts[2];\n      const episodeId = parts[3];\n      \n      console.log(`[Extractor] FlixHQ ID: ${flixhqId}, Episode ID: ${episodeId}`);\n      \n      // Try to get stream from Consumet\n      for (const baseUrl of this.consumetUrls) {\n        try {\n          console.log(`[Extractor] Trying to get stream from ${baseUrl}...`);\n          \n          let watchUrl;\n          if (mediaType === \"movie\") {\n            watchUrl = `${baseUrl}/movies/flixhq/watch?episodeId=${episodeId}&mediaId=${flixhqId}`;\n          } else {\n            watchUrl = `${baseUrl}/movies/flixhq/watch?episodeId=${episodeId}&mediaId=${flixhqId}`;\n          }\n          \n          console.log(`[Extractor] Watch URL: ${watchUrl}`);\n          \n          const response = await fetch(watchUrl);\n          if (!response.ok) {\n            console.log(`[Extractor] ${baseUrl} returned ${response.status}`);\n            continue;\n          }\n          \n          const data = await response.json();\n          console.log(`[Extractor] Stream data:`, data);\n          \n          if (!data.sources || data.sources.length === 0) {\n            console.log(`[Extractor] No sources from ${baseUrl}`);\n            continue;\n          }\n          \n          const source = data.sources.find(s => s.quality === \"auto\" || s.quality === \"default\") || data.sources[0];\n          console.log(`[Extractor] Found stream URL: ${source.url.substring(0, 50)}...`);\n          console.log(`[Extractor] This is a REAL HLS stream!`);\n          \n          const subtitles = (data.subtitles || []).map((sub, index) => ({\n            id: `sub-${index}`,\n            language: sub.lang || \"Unknown\",\n            url: sub.url,\n            isDefault: sub.lang === \"English\",\n          }));\n          \n          return {\n            server: server,\n            headers: {\n              \"Referer\": \"https://flixhq.to/\",\n            },\n            videoSources: [{\n              url: source.url,\n              type: \"hls\",\n              quality: \"auto\",\n              subtitles: subtitles,\n            }],\n          };\n        } catch (err) {\n          console.error(`[Extractor] Error with ${baseUrl}:`, err);\n          continue;\n        }\n      }\n      \n      throw new Error(\"All stream extraction attempts failed\");\n    } catch (err) {\n      console.error(\"[Extractor] findEpisodeServer error:\", err);\n      throw err;\n    }\n  }\n}"
}
